<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Animated Hurricane Heatmap</title>
    <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
    <!-- Mapbox GL JS CSS -->
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
    <style>
        body { margin: 0; padding: 0; }
        #map { position: absolute; top: 0; bottom: 0; width: 100%; }
    </style>
</head>
<body>
    <!-- Map Container -->
    <div id="map"></div>

    <!-- Include Mapbox GL JS -->
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>

    <!-- Include Turf.js (if needed) -->
    <!-- <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script> -->

    <!-- Your Script -->
    <script>
        // Define the hurricane path
        const hurricanePath = {
            "type": "Feature",
            "geometry": {
                "type": "LineString",
                "coordinates": [
                    [-75, 25],
                    [-80, 26],
                    [-77, 27],
                    [-80, 28],
                    [-79, 29],
                    [-80, 30],
                    [-81, 31],
                    [-82, 32]
                ]
            }
        };

        // Your Mapbox access token
        mapboxgl.accessToken = 'pk.eyJ1IjoiYXd1ZGFsaSIsImEiOiJjbTJmejYwaHowZmQ1Mm9wcXpsZmw3bHhmIn0.KWUuBXHZ-IyAFPtw38r0nQ';

        // Initialize the map
        const map = new mapboxgl.Map({
            container: 'map', // Container ID
            style: 'mapbox://styles/mapbox/light-v10', // Map style
            center: [-75, 25], // Initial map center [lng, lat]
            zoom: 5 // Initial zoom level
        });

        // Add zoom and rotation controls
        map.addControl(new mapboxgl.NavigationControl());

        // Function to generate logarithmic spiral heatmap data around a center point
        function generateLogarithmicSpiralData(center) {
            const points = [];
            const numSpirals = 5; // Number of spiral arms
            const pointsPerSpiral = 1000; // Points per spiral arm
            const spiralSpacing = (2 * Math.PI) / numSpirals; // Angular spacing between spirals
            const a = 0.1; // Controls the initial radius
            const b = Math.random() * (0.25 - 0.22) + 0.22; // Controls the tightness of the spiral

            const maxTheta = pointsPerSpiral * 0.04; // Adjusted angle increment to match 'theta' in the loop
            const maxRadius = a * Math.exp(b * maxTheta); // Maximum radius for intensity calculation

            for (let s = 0; s < numSpirals; s++) {
                const spiralOffset = s * spiralSpacing;
                for (let i = 0; i < pointsPerSpiral; i++) {
                    const theta = i * 0.02; // Angle parameter (ensure it matches 'maxTheta' calculation)
                    const radius = a * Math.exp(b * theta); // Logarithmic spiral equation

                    // Add some randomness to the radius and angle
                    const randomRadius = radius + (Math.random() - 0.5) * 0.02;
                    const randomTheta = theta + (Math.random() - 0.5) * 0.2;

                    // Calculate coordinates
                    const x = randomRadius * Math.cos(randomTheta + spiralOffset);
                    const y = randomRadius * Math.sin(randomTheta + spiralOffset);

                    // Adjust for longitude distortion at different latitudes
                    const offsetLng = x / Math.cos(center[1] * Math.PI / 180);
                    const offsetLat = y;

                    // Calculate intensity based on radius (closer to center = higher intensity)
                    const intensity = Math.max(1 - (radius / maxRadius - 0.2), 0);

                    points.push({
                        "type": "Feature",
                        "geometry": {
                            "type": "Point",
                            "coordinates": [center[0] + offsetLng, center[1] + offsetLat]
                        },
                        "properties": {
                            "intensity": intensity
                        }
                    });
                }
            }

            return {
                "type": "FeatureCollection",
                "features": points
            };
        }

        map.on('load', () => {
            // Initialize the heatmap source with an empty FeatureCollection
            map.addSource('hurricane-heatmap', {
                "type": "geojson",
                "data": {
                    "type": "FeatureCollection",
                    "features": []
                }
            });

            // Add the heatmap layer
            map.addLayer({
                "id": "hurricane-heatmap",
                "type": "heatmap",
                "source": "hurricane-heatmap",
                "maxzoom": 9,
                "paint": {
                    "heatmap-weight": ["get", "intensity"],
                    "heatmap-intensity": [
                        "interpolate",
                        ["linear"],
                        ["zoom"],
                        0, 1,
                        9, 3
                    ],
                    "heatmap-color": [
                        "interpolate",
                        ["linear"],
                        ["heatmap-density"],
                        0, "rgba(0, 0, 255, 0)",    
                        0.1, "rgb(0, 0, 255)",      
                        0.3, "rgb(0, 255, 0)",      
                        0.5, "rgb(255, 255, 0)",   
                        0.7, "rgb(255, 165, 0)",    
                        0.9, "rgb(255, 69, 0)",     
                        1, "rgb(255, 0, 0)"         
                    ],
                    "heatmap-radius": [
                        "interpolate",
                        ["linear"],
                        ["zoom"],
                        0, 2,
                        9, 30
                    ],
                    "heatmap-opacity": 1
                }
            });

            startAnimation();

            function startAnimation() {
                let counter = 0;
                const steps = hurricanePath.geometry.coordinates.length;

                function animate() {
                    const currentPosition = hurricanePath.geometry.coordinates[counter];
                    const heatmapData = generateLogarithmicSpiralData(currentPosition);
                    map.getSource('hurricane-heatmap').setData(heatmapData);

                    counter++;

                    if (counter < steps) {
                        setTimeout(animate, 1000); 
                    }
                }

                animate();
            }
        });
    </script>
</body>
</html>
